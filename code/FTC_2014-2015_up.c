#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S4, HTServo,  HTServo,  none,     none)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop, encoder) //FL
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop, encoder) //BL
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop, encoder) //FR
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop, encoder) // BR
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorJ,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S4_C1_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_5,    servo5,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoStandard)
#pragma config(Servo,  srvo_S4_C2_1,    servo7,               tServoNone)
#pragma config(Servo,  srvo_S4_C2_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S4_C2_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S4_C2_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S4_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S4_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "JoystickDriver.c"

#define autonom
#include "inicializate_motors.h"

void L_R (const byte speedLeft, const byte speedRight, const byte waitTime) // + forward; - backward
{
	motor[FR] = -speedRight;
	motor[FL] = speedLeft;
	motor[BR] = speedRight;
	motor[BL] = -speedLeft;
	wait1Msec(waitTime);
}

void UP (const byte speed, const int waitTime) // control of lift by "wait"
{
	motor[UR] = speed;
	motor[UL] = -speed;
	motor[URT] = speed;
	motor[ULT] = -speed;
	wait1Msec(waitTime);
}

void L_R_UP (const byte speedLeft, const byte speedRight, const byte speedLift, const byte waitTime)
{
	motor[FR] = -speedRight;
	motor[FL] = speedLeft;
	motor[BR] = speedRight;
	motor[BL] = -speedLeft;
	motor[UR] = speedLift;
	motor[UL] = -speedLift;
	motor[URT] = speedLift;
	motor[ULT] = -speedLift;
	wait1Msec(waitTime);
}

void Servosetup() // initialization of servos and motors
{
	inicializete_motors();
	//inicializate_resetPower();
}


void zero(const byte waitTime = 1)
{
  L_R_UP(0, 0, 0, waitTime);
}

void motion_elevator(const unsigned int rideDistance, int h)
{
	nMotorEncoder[BL] = 0;
	nMotorEncoder[UL] = 0;
	while (abs(nMotorEncoder[BL]) < rideDistance && abs(nMotorEncoder[UL]) < h)
	{
  		L_R_UP(20, 20, 100, 1);
  }
  zero();
  while (abs(nMotorEncoder[BL]) < rideDistance)
	{
			L_R(20, 20, 1);
	}
	zero();
}

void motion(int l_ramp_goal, int a) // moving to rolling goal and capture it
{
  nMotorEncoder[FR] = 0;
	nMotorEncoder[BL] = 0;
  l_ramp_goal *= 1024 / 3.1415 * 10;
  while(abs(nMotorEncoder[BL]) < l_ramp_goal)
	{
    L_R(a * -20, a * -20, 1);
  }
  servo[servoMvClawsRight] = Goal_Captured;
  servo[servoMvClawsLeft] = difference - Goal_Captured;
  wait10Msec(10)
  while(abs(nMotorEncoder[BL]) < l_ramp_goal + 200)
  {
    L_R(a * -20, a * -20, 1);
  }

  zero();
}

void elevator(int h) // raise the bucket and overturn it
{
	nMotorEncoder[UL] = 0;

 	while(abs(nMotorEncoder[UL]) < h)
	{
    UP(100, 1);
  }

  UP(0, 1);

  servo[servoTubeLeft] = Bucket_Overturned;
  servo[servoTubeRight] = Bucket_Overturned;
  wait1Msec(3500);

  servo[servoTubeLeft] = Bucket_Vertical;
  servo[servoTubeRight] = Bucket_Vertical;

  while(abs(nMotorEncoder[UL]) > 10)
  {
    UP(-100, 1);
  }

  UP(0, 1);
}

void R(float l_ramp_goal, int pow) // turn by right wheel pair
{
	nMotorEncoder[FR] = 0;
	while(abs(nMotorEncoder[FR]) < l_ramp_goal)
	{
    L_R(0, pow, 1);
  }

  zero();
}

void L(float l_ramp_goal, int pow) // turn by left wheel pair
{
	nMotorEncoder[BL] = 0;
	while(abs(nMotorEncoder[BL]) < l_ramp_goal)
	{
    L_R(pow, 0, 1);
    nxtDisplayBigTextLine(2, "%i", nMotorEncoder[FR]);
  }

  zero();
}

void rotate(float l_ramp_goal) // moving on circle
{
	wait1Msec(500);
	nMotorEncoder[BL] = 0;
	nMotorEncoder[FR] = 0;
	while(abs(nMotorEncoder[FR]) < l_ramp_goal)
	{
    L_R(-60, 100, 1);
  }

  L_R(100, 100, 1);

  zero();
}

void rotate2(float l_ramp_goal) // "tank turning"
{
	wait1Msec(500);
	nMotorEncoder[BL] = 0;
	nMotorEncoder[FR] = 0;
	while(abs(nMotorEncoder[FR])  < l_ramp_goal)
	{
    L_R(50, -100, 1);
  }
  L_R(100, 100, 1);

  zero();
}

void LR(int pow, float l_ramp_goal) // moving
{
	nMotorEncoder[BL] = 0;
	while(abs(nMotorEncoder[BL]) < l_ramp_goal)
	{
	  motor[FR] = -pow;
	  motor[BR] = pow;
	  motor[FL] = pow;
	  motor[BL] = -pow;
  }

  motor[FR] = 0;
  motor[BR] = 0;
  motor[FL] = 0;
  motor[BL] = 0;
}

void rotate_left(const unsigned int l_turn)
{
	nMotorEncoder[BL] = 0;
	nMotorEncoder[FR] = 0;
	while(abs(nMotorEncoder[FR]) < l_turn)
	{
    L_R(-100, 100, 1);
  }

  zero();
}

void rotate_right(const unsigned int l_turn)
{
	nMotorEncoder[FL] = 0;
	nMotorEncoder[FR] = 0;
	while(abs(nMotorEncoder[FR]) + abs(nMotorEncoder[FL]) < l_turn * 2)
	{
    L_R(50, -50, 1);
  }

  zero();
}


void LR(const byte pow, unsigned int l_ramp_goal) // moving
{
	nMotorEncoder[BL] = 0;
  l_ramp_goal *= 1024 / 3.1415 * 10;
	while(abs(nMotorEncoder[BL]) < l_ramp_goal)
	{
	  motor[FR] = -pow;
	  motor[BR] = pow;
	  motor[FL] = pow;
	  motor[BL] = -pow;
	  nxtDisplayBigTextLine(1, "%d", nMotorEncoder[BL]);
  }

  motor[FR] = 0;
  motor[BR] = 0;
  motor[FL] = 0;
  motor[BL] = 0;
}

task main()
{
	 Servosetup();
	 wait10Msec(100);
	 waitForStart();
   servo[servoMvClawsRight] = Goal_Released;
   servo[servoMvClawsLeft] = difference -  Goal_Released;
   wait10Msec(1);
   motion(210, 1); // ride to the 60cm goal
   wait10Msec(10);
   elevator(7300); // put the ball to 60cm goal
   rotate_right(580);// rotate with 60cm goal
   wait10Msec(10);
   LR(100, 245);
  /*L(1500, -100);//
   LR(-20, 1500); // go back with 60cm goal
   servo[servoMvClawsRight] = Goal_Released; //release 60cm goal
   servo[servoMvClawsLeft] = difference - Goal_Released;
   LR(20, 1500); // return
   rotate2(3000); // rotate to 90cm goal and stop near the 60cm goal
   servo[servoMvClaws2] = Goal_Side_Captured; // capture to 30cm goal
   rotate2(1000); // rotate to 90cm goal
   motion(1500, 1); // ride to the 90cm goal and capture it
   //elevator(10000); // put the ball to 90cm goal
   R(1500, 100); // rotate to the parking zone
   LR(50, 10000); // move rolling goals to the parking zone
   L(2000, 100); // rotate in the parking zone
   LR(50, 1000); // moving in parking zone*/
	 zero();
	 //OFF_power();
}
